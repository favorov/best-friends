---
title: "Best friends: what cloud is friendly to this tag? Is it actually friendly?"
output: rmarkdown::html_vignette

vignette: >

 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteIndexEntry{Best friends: what cloud is friendly to this tag? Is it actually friendly?}
 %\VignetteIndexEntry{best.friends}
 %\VignetteIndexEntry{best.friends.of}
 %\VignetteIndexEntry{best-friends-of}
 %\VignetteIndexEntry{best-friends}
 %\VignetteEncoding{UTF-8}
 %\VignetteDepends{devtools}



---

[SI AUGUSTUM VIDEAT AMICOS EIUS VIDEATI]{style="float:right"}

##

`r format(Sys.Date(), "%d %b %Y")` 

`r library(knitr)`
`r library(markdown)`
`r library(best.friends)`
`r options(width=80,keep.source=TRUE)`
`r opts_chunk$set(echo=TRUE,message=FALSE,cache=FALSE,warning=FALSE)`
<!-- cache is off, we save all the necessary things in Rda -->

<div style="line-height: 1.5em;">

## Introduction-old

There is a simple intuition of what does it mean to be a friend. A friend of Augustus cares about Augustus more than about other persons. And, if one sees Augustus, it makes sense to infer to see friends(s) of Augustus also. Let's try to translate it to statistical inferences.

We have a set C of clouds and a set T of tags, e.g. a set of word/term/tag clouds as described at https://en.wikipedia.org/wiki/Tag_cloud. Each tag is somehow related to each cloud, and the strength of the relation varies from one (tag,cloud) pair to another. We refer to the relation strength as the attention that a cloud pays to a tag. The attention that each cloud pays to each tag is represented by a real value. The attention actually can be any type of relation measure, e.g. fuzzy membership. The absence of the attention is supposed to be represented by the smallest value, naturally, it is 0 and all the attention values are are positive (not required). The attention values is a $|T| \times |C|$ matrix $A$.

The tag-cloud-attention metaphor allows to represent a lot of applications in bioinformatics and statistics. The examples are gene patterns (cloud) and genes (tags) loads (attention) in the patterns; fuzzy sets (clouds, their elements (tags) and the inclusion degree (attention); weighted graph vertices (tags) and each vertex neighbourhood (cloud), here the attention is the weight of the edge.

        Example                           tag $t$         cloud $c$                           attention $A\left(t,c\right)$
--------------------------------------   -------------   ----------------------------------  ----------------------------
[gene regulation by TFs](#toyTF)          gene            genes under the TF regulation       strength of regulation
[transctironal correlations](#toynet)     gene            genes coexpressed with a gene       transcription correlation
fuzzy clustering                          object          cluster                             object weight in cluster
transcription decomposition               transcript      transcription pattern               transcript's load in pattern
weighted graph                            vertex          another vertex                      weight of edge between cloud and tag
--------------------------------------   -------------   ----------------------------------  ----------------------------

Let's think a bit more about the first example. We look at a gene and we want to know whether a TF (transcription factor) is its friend, i.e. whether the TF specifically regulates the gene. The na&iuml;ve idea is to look for a TF that the gene is the most sensitive for. Still, it's possible that this TF is the strongest for the most of the genes. Sometimes, it is what we want to find, but now we want to answer other questions, namely, what TF is the most specific factor for the gene and is the specificity enough to say that is does not look like a random outcome?

Now, the question. For each tag, we want to identify the cloud(s) that specifically prefer(s) the tag. We say that such a cloud is a friend (or the best friend if it is the only) for the tag. The simplest example: imagine that only one cloud pays attention to our tag.

To identify the friends(s), first, for each cloud, we rank all the tags by the attention the cloud pays to the tag. The ranking the decreasing, the first is the best. In other words, We create the rank matrix $R$ of the same $|T| \times |C|$ size, and each element is the corresponding attention's rank inside inside the column of the attention matrix. We normalise the values to be in $[0,1]$ by dividing by $|T|$ and we refer to the normalised ranks as $r$ matrix. Now, for each tag, we define the degree of friendliness of a cloud for this tag, by decreasingly ranking the tag's row in $r_{i,j}=r(t_i,c_j)$ matrix. The most friendly cloud $c_{(1)}(t_i)$ is the cloud with the minimal value of $r_{ij}$, the next is $c_{(2)}(t_i)$, etc, etc.

If a cloud is best friend, it is to be the most friendly cloud for the tag, but it is not enough. In any ranking, there is a first element, and we want to estimate the probability to observe what we observe by random. The null-hypothesis we use to picture a random setup is that in any column of $A$ all the elements are i.i.d., or, in other word, the attentions that a cloud pays to all the tags are independently sampled from the same distribution. The distributions can differ from cloud to cloud.

The statistics we use to test whether the most friendly cloud for the tag $t_i$ is really the best friend is the difference $t$ between the values $r(t_i,c_{(2)}(t_i))$ and $r(t_i,c_{(1)}(t_i))$, in other words, between the next-after-the-best and the best values $r$ for the tag $t_i$. We estimate the probability (p-value) to observe this difference as $<=t$ given the null-hypothesis proposition. If p-value is small enough, we reject the null, and claim that the friendliness of the cloud $c_{(1)}(t_i)$ is unlikely to observe by random and so we refer to it as the best friend of $t_i$. In this case, $t_i$ is a marker of its best friend cloud $c_{(1)}(t_i)$.

For a similar test that splits all the clouds into $m$ friends of the tag and the remaining $|C|-k$ clouds uses the difference  $r(t_i,c_{(m+1)}(t_i))$ and $r(t_i,c_{(m)}(t_i))$. If we obtain the p-value that is small enough, we claim that the clouds $c_{(1)}(t_i)$..$c_{(m)}(t_i)$ are friends of $t_i$ and $t_i$ is their marker.

Sometimes, the clouds are in in one-to-one relation with the tags, e.g. [each $c$ is a set of neighbours of $t$ in some graph](#toynet). For this example, $A$ is a weighted adjacency matrix of this graph and it is symmetric. This symmetric case is a very specific case. Still, even for symmetric $A$, friendship relation itself is asymmetric: a friend cares about Augustus, while Augustus does not.

## Introduction

There is a simple intuition of what it means to be a friend. A friend of Augustus cares about Augustus more than about other people. And, if we see Augustus, then we infer to see friends(s) of Augustus also. Letâ€™s translate it into statistical language.

Consider a set of genes and their loads in a set of expression patterns. Each pattern represents a biological process by the expression levels of the involved genes. 

Sometimes, the expression of a single gene indicates the activity of the entire pattern. In the simplest case, the gene has a nonzero load in only one pattern. 
Moreover, the gene may have several nonzero loads, but all of them but one are relatively small. Then the gene (AKA Augustus) is the marker gene for the pattern, and the marked pattern is the best friend of this gene. We want to identify the marker genes and corresponding patterns statistically.  

\paragraph{Model} The bipartite graph naturally fits this model. To generalise the example, we will refer to genes as \textit{{\tag}s}, to expression patterns, as \textit{{\cloud}s}, and to any load as \textit{attention}. The sketch below illustrates the setting.

![The bipartite graph picture shows only edges with nonzero values](bipartite.jpg)

To be more specific, we are given a set of clouds $C = \{c_1, \dots, c_k\}$, and a set of tags $T = \{t_1, \dots, t_n\}$.
Each tag $t \in T$ and cloud $c \in C$ are related by the attention $A(t, c)$, that the cloud pays to the tag. The strength of attention varies from $0$ to infinity, $A(t, c)\ge 0$. 

In the following, the attention values are stored in $n\times k$ matrix $\mathcal{A}$. 

The tag-cloud-attention model applies to many problems in bioinformatics and statistics.

        Example                           tag $t$         cloud $c$                           attention $A\left(t,c\right)$
--------------------------------------   -------------   ----------------------------------  ----------------------------
[gene regulation by TFs](#toyTF)          gene            genes under the TF regulation       strength of regulation
[transctironal correlations](#toynet)     gene            genes coexpressed with a gene       transcription correlation
fuzzy clustering                          object          cluster                             object weight in cluster
transcription decomposition               transcript      transcription pattern               transcript's load in pattern
weighted graph                            vertex          another vertex                      weight of edge between cloud and tag
--------------------------------------   -------------   ----------------------------------  ----------------------------



\paragraph{Goal} For each tag, we want to identify the cloud(s) that particularly prefer(s) the tag, if any. Then such a cloud is a friend (or the best friend if there is only one) for the tag. The simplest example: imagine that only one cloud pays attention to the tag in hand. We intend to express the meaning of the word "particularly" in this context by a statistical test.




## Best friends

For each tag, we estimate the p-value for the difference of the best and the next normalised ranks of attentions of clouds to the tag. According to zero hypothesis, are the best two from a set of $|C|$ uniformely i.i.d. values The uncorrected p-value is $\left(1-t\right)^{\left|C\right|}$. See the preprint () for the details. If the p-value after the correction for multiple (actually, $\left|T\right|$) hypotheses, the best cloud $c_{(1)}(t)$ is the best friend for the tag $t$. In tis case, we also can say that $t$ is a marker for $c_{(1)}(t)$.

For each tag, the `best.friends.of` function returns the possible best friend and the corresponding uncorrected p-value for the observation provided the null model.

## Friends

The `best.friends.of` approach works great if the tag $\epsilon$ has only one friendly cloud, while all the others are much more neutral about $\epsilon$. What happens if there are more than one friendly cloud, and the remainder is neutral for $\epsilon$. The difference between the best and the best-after-the-best is very small, and if fits the null hypothesis really well. But, if we go on looking at sequential differences  $t_j= r\left(\epsilon , c_{j+1}\left(\epsilon \right ) \right ) - r\left(\epsilon , c_j\left(\epsilon \right ) \right )$, one of them, that is the gap between friendly clouds and neutral clouds, can be unexpectedly high. For the worst rank of the tag (it has number |C| in the ranking),  $t_{|C|}= 1 - r\left(\epsilon , c_{|C|}\left(\epsilon \right ) \right )$. The p-value for each of these $t$ values is the same, e.g. $\left(1-t_j\right)^{\left|C\right|}$. The number of hypotheses to correct for is $\left|E\right|\left|C\right|$.

## Code and examples in R

```{r source, echo=FALSE}
data.digits=2
p.val.digits=4
```
</div>

### Toy example

Let's start with something supersimple.

```{r}
relation<-matrix(ncol = 3,nrow=7)
rownames(relation)<-c("Tag1","Tag2","Tag3","Tag4","Tag5","Tag6","Tag7")
colnames(relation)<-c("Cloud1","Cloud2","Cloud3")
relation[1,]<-c(0.2,0.1,0.3)
relation[2,]<-c(2,3,1)
relation[3,]<-c(0.1, 6 ,0.05 )
relation[4,]<-c(0.4, 1 ,3 )
relation[5,]<-c(0.25,0.15 ,0.3 )
relation[6,]<-c(2,0.9 ,0.4 )
relation[7,]<-c(.7,0.1 ,11 )
noquote(relation)
```
Let's run the best friends test.
```{r}
friends<-best.friends.test(relation)
noquote(format(friends,digits = p.val.digits))
```
Cloud 2 is the best friend of tag 3, and it is the only result with p-value less than 0.05. Makes sense. Tag 3 is the best in the cloud 2, while it is the worst in other two clouds.

### <a name="toyTF"></a> Toy regulation example

Let's return to the regulation example. We have ten TFs (TF1, TF2, ..) and ten genes (A,B,...) The strength of the regulation is shown by the matrix. The tags are genes, the clouds are derived from their regulation by TFs.

```{r}
genes<-10
regulation=matrix(
	c(0.2, 0.2, 0.2, 0.2, 0.25, rep(0.2,genes-5),
	  rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes),
		rep(1, genes)
    ),
	ncol=10,byrow=FALSE
)
gene.names<-LETTERS[seq( from = 1, to = genes )]
TF.names<-c('TF1','TF2','TF3','TF4','TF5','TF6','TF7','TF8','TF9','TF10')
rownames(regulation)<-gene.names
colnames(regulation)<-TF.names
```
So, we prepared the relation matrix.

```{r}
noquote(format(regulation,digits = data.digits))
```
Tags (genes) are rows, clouds (TFs) are columns, it is consistent with $A\left(e,c\right)$ notation.

Searching for the best friend TF for each gene:

```{r}
friends<-best.friends.test(regulation)
noquote(format(friends,digits = p.val.digits))
```

Only gene E (the fifth) has a reliable best friend, and it is TF1. It is what we could see in the relation matrix, so what we calculate here is consistent with the intuition.

Let's search for the all possible friends for all genes.
```{r}
all.friends<-friends.test(regulation)
noquote(all.friends)
```

Again, only gene E (the fifth) has a reliable best friend, and it is TF1.
It is interesting to see that the tenth (worst) rank of all the genes is unexpectedly far away from 1 (the right column). It is an effect of ties, the worst ranks of all the genes but E but E are 5.5 and E is 6.

Add some randomness to the equal columns:
```{r}
set.seed(42)
regulation<-jitter(regulation)
noquote(format(regulation,digits = data.digits))
```

And, let's search for best friends again:

```{r}
friends<-best.friends.test(regulation)
noquote(format(friends,digits = p.val.digits))

```
And, for all friends:


```{r}
all.friends<-friends.test(regulation)
noquote(all.friends)
```

Almost all the effects disappear. There is some week signal for gene E is for {TF1,TF9,TF7,TF10} (uncorrected p-value=0.006).



### <a name="toynet"></a> Toy net example

![Toy network example](green-6.png)

Let's represent the graph on the picture by its weighted adjacency matrix. The diagonal tags are NAs.

```{r}
connections<-matrix(nrow = 10,ncol=10,0)
names<-c('red','purple','blue','orange','green.1','green.2','green.3','green.4','green.5','green.6')
rownames(connections)<-names
colnames(connections)<-names
connections[,'red']<-5
connections['red',]<-5
connections['orange','red']<-0
connections['red','orange']<-0
connections['blue','orange']<-3
connections['orange','blue']<-3
connections['purple','blue']<-1
connections['blue','purple']<-1
diag(connections)=NA
noquote(format(connections,digits = data.digits))
```
Let's search for best friends (here, the diagonal is neglected by the construstion, and we let the test know it):

```{r}
friends<-best.friends.test(connections,neglect_diagonal = TRUE)
noquote(format(friends,digits = p.val.digits))

```
the blue is the best friend for the orange (uncorrected p-value=0.013).

All friends test:

```{r}
all.friends<-friends.test(connections)
noquote(all.friends)
```
The same friendship: the blue is the best friend for the orange. All the nodes but the red are better friends for the the orange than the red is ((uncorrected p-value=0.03)).

