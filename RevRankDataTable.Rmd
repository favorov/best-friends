What genes are connected with our genes: rank of backward ranks
========================================================

Alexander Favorov  
-----------------------------------------------

### `r format(Sys.Date(), "%d %b %Y")` 

`r library('knitr')`
`r options(width=80,keep.source=TRUE)`
`r opts_chunk$set(echo=T,message=F,cache=F,warning=F)`
<!-- cache is off, we save all the neccessary things in Rda -->


### Gene rank and reverse (double) rank

Suppose we have a kind of gene-to-gene correlation matrix. The closer the genes are, the closer the value is to $1$, otherwise - to $-1$. Actually, the following holds for any comparable value, we will refer to it as a correlation just to be more definite. We want to find the list of best 'friends' for each (or for some particular) gene. The naive approach would be to rank all the genes by our-to-him correlation. If we use it, we cannot tell the genes that are correlated with everything from genes that are correlated specifically with our gene. We could try to post a kind of normalization, but it narrows the method (the precedure is to be whatever defined) and it prefers the genes that have a few friend for those that have a lot instead of to prefer specific friends of our gene for those that are friends of everybody, and it is not exactly the same thing.

The backwards-rank approach we use here is based on a simple proposition that for a tested gene that is a friend of our gene (to be more formal, it is specifiacaly correlated with our gene of interest), the rank of our gene in the tested gene's correlations list is to be rather high. Otherwise, if the tested gene is a firend-of-everybody, our gene's rank in his list can be quite low, while the tester's gene rank in our list is still high. Thus, we gather the the 'where we are in his list' ranks and then we sort this ranks to create the best-friends list.

### Gene rank and reverse (double) rank : formal description

Suppose we have similarity(correlation) matrix $C_{ij}$ for time- or sample- series of a set of $k$ genes $G=\{g_i: i\in1..k\}$. The requirements for the matrix itself are very relaxed - it is to represent similarity of the series corresponding to genes and $C_{ij}\gt C_{il}$ means that $g_i$ series are more similar to $g_j$ than to $g_l$.

Now, we want to rank all genes ${G \backslash g_i}$ by their specific concordance (friendship) with gene $g_i$. The ranking by $C_{ij}$ will rank genes by the common trancription pattern similarity rather than by specific similarity with $g_j$. Instead of this, let's define the friendship function $F(j|i)$ that is the rank of $C_{ij}$ in the list of all $C_{lj}$. In other words, the friendship function of $j$ to $i$ is the rank of $i$ in the $C_{*j}$ list (backwards rank).

Now, it's easy to define the best friends (the most concordant genes) of gene $g_i$. The higher is the $F(j|i)$, the better is the friend. The best $N$ friends of $g_i$ is the top-$N$ of the ordered $F(j|i)$ list.

```{r source, echo=FALSE}
source('backwards.rank.data.table.R')
```

### Code and examples in R

#### Sorting by backwards ranking

First, we need a function that arrange (sort) tester genes by the backwards ranking. The input is square matrix with the correaltion. The output is the matrix where the rows are named by genes and each row contain sorted set of friends of the row-naming gene, the best is first.

Here is the code of the function:
```{r show.sort.code}
sort.by.backwards.rank
```

And now, let's prepare a simple example. We have 5 genes (A,B,...D). A is strongly correlateds with everybody; B and C has correlation 0.75, all others are more or less independent. Naive approach would idetify A as best frind for B and C.

```{r}
library(data.table)
correl=matrix(
	c(1,0.9,0.9,0.9,0.9,0.9,1,0.75,0.2,0.25,0.9,0.75,1,0.20,0.22,0.9,0.2,0.2,1,0.15,0.9,0.25,.22,.15,1),
	ncol=5,byrow=TRUE
)
gene.names<-c('A','B','C','D','E')
colnames(correl)<-gene.names
corr.table<-data.table(idx=gene.names,correl)
corr.table
```

Applying the function to our example.

```{r}
genelists<-sort.by.backwards.rank(correl)
genelists
```

B and C are mutually best friends (see column 2 of B and C row), it is exactly what we want to see. The first column is trivial: every gene is the best friend to itself. 

#### Ranking by backwards ranking

Sometimes, it is necessary to have ranks $F(i|j)$ for all genes rather than the ordered list. This is the version of the code.
Again, the input is square matrix with the correaltion. The output is the matrix of the ranks-of-reverse-ranks that order the genes by how freindly are they to the gene that is represented by a row. Row is 'our' gene, column is the tester. The matrix is asymmetric.

Here is the code of the function:
```{r show.rank.code}
rank.by.backwards.rank
```

Let's apply the functions to our example.

```{r}
ranks<-rank.by.backwards.rank(correl)
ranks
```

#### Distance by backwards ranking

To apply most standard clustering techniques, we need a symmetric distance with self-distance = 0. It can be done if we add the direct and reverse ranks form previous function (A for B and B for A), decrease them both by 1 to achieve |GG|=0 for any gene G and, eventually, map it o [0,1] interval. We can also treat this distance as a kind of p-value is we suupiose that the rank is distributed uniformely.  

Code of the function:
```{r show.distance.code}
distance.by.backwards.rank
```

Applying to our example:

```{r}
distance<-distance.by.backwards.rank(correl)
distance
```

