What genes are connected with our genes: rank of backward ranks
========================================================

Alexander Favorov  
-----------------------------------------------

### `r format(Sys.Date(), "%d %b %Y")` 

`r library('knitr')`
`r options(width=80,keep.source=TRUE)`
`r opts_chunk$set(echo=T,message=F,cache=F,warning=F)`
<!-- cache is off, we save all the neccessary things in Rda -->


### Gene rank and rank-reverse-rank

Suppose we have a kind of gene-to-gene correlation matrix, e.g. correlation of expression. The more the genes are alike, the lager the value is. Actually, the following holds for any kind of comparable value, we will refer to it as a correlation just to be more definite. We want to find the list of best 'friends' for each (or for some particular) gene (our gene). Friends are the genes (they) that are the closest to our gene. The naïve approach would be to rank all the genes by our-to-him correlation. Its drawback is that we cannot tell the genes that are correlated with everything from genes that are correlated specifically with our gene. A kind of normalization could be applied to the correlation vectors of ‘they’ genes, but it is a way to prefer the genes that have a few friend for those that have a lot instead of to prefer specific friends of our gene for those that are friends of everybody, and it is not exactly the same thing. In addition, the result of ranking of normalized data can depend on the normalization procedure more than on the initial data.

The rank-backwards-rank (RBR) approach we propose here is based on a simple proposition that for a gene that is a good friend of our gene (to be more formal, it is specifically correlated with our gene), the rank of our gene in the tested gene's correlations list is to be rather high. Otherwise, if the tested gene is a friend-of-everybody, our gene's rank in his list can be quite low, while the tester's gene rank in our list is still high. Thus, we gather the the 'where we are in his list' ranks and then we sort this ranks to create the best-friends list.


### Gene rank and reverse (double) rank : formal description

Suppose we have similarity (e.g., correlation) matrix $C_{ij}$ for time- or sample- series of a set of $k$ genes $G=\{g_i: i\in1..k\}$. The requirements for the matrix itself are very relaxed - it is to represent similarity of the series corresponding to genes and $C_{ij}\gt C_{il}$ means that $g_i$ series are more similar to $g_j$ than to $g_l$.

Now, we want to rank all genes $\{G \backslash g_i\}$ by their specific concordance (friendship) with gene $g_i$. The ranking by $C_{ij}$ will rank genes $g_j$ by their with $g_i$ similarity rather than by specific similarity with. Instead of this, let's define the friendship function $F(j|i)$ that is the rank of $C_{ij}$ in the list of all $C_{lj}$. In other words, the friendship function of $j$ to $i$ is the rank of $C_{ij}$ in the $C_{*j}$ list (backwards rank).

Now, it's easy to define the best friends (the most concordant genes) of gene $g_i$. The higher is the $F(j|i)$, the better is the friend. The best $N$ friends of $g_i$ is the top-$N$ of the ordered $F(j|i)$ list.

```{r source, echo=FALSE}
if (!suppressWarnings(require('gene.best.friends')))
{
	if (!suppressWarnings(require('devtools')))
	{
		source("http://bioconductor.org/biocLite.R")
		biocLite("devtools")
		library("devtools")
	}
	install_github('favorov/gene-friends/pkg')
	library(gene.best.friends)
}
```

### Code and examples in R

#### Sorting by backwards ranking

First, we need a function that arrange (sort) tester genes by the backwards ranking. The input is square matrix with the correaltion. The output is the matrix where the rows are named by genes and each row contain indices of sorted set (indices) of friends of the row-naming gene, the best is first.

And now, let's prepare a simple example. We have 5 genes (A,B,...D). A is strongly correlateds with everybody; B and C has correlation 0.75, all others are more or less independent. Naive approach would idetify A as best frind for B and C.

```{r}
correl=matrix(
	c(1.00, 0.95, 0.92, 0.96, 0.97,
		0.95, 1.00, 0.75, 0.20, 0.25,
		0.92, 0.75, 1.00, 0.20, 0.22,
		0.96, 0.20, 0.20, 1.00, 0.15,
		0.97, 0.25, 0.22, 0.15, 1.00),
	ncol=5,byrow=TRUE
)
gene.names<-c('A','B','C','D','E')
colnames(correl)<-gene.names
rownames(correl)<-gene.names
correl
```

Applying the function to our example.

```{r}
ranklists<-OrderByBackwardsRank(correl)
ranklists
```

We want to see gene names rather than indices:

```{r}
genelists<-apply(ranklists,2,function(col) gene.names[col])
genelists
```

B and C are mutually best friends (see column 2 of B and C row), it is exactly what we want to see. The first column is trivial: every gene is the best friend to itself. 

#### Ranking by backwards ranking

Sometimes, it is necessary to have ranks $F(i|j)$ for all genes rather than the ordered list. This is the version of the code.
Again, the input is square matrix with the correaltion. The output is the matrix of the ranks-of-reverse-ranks that order the genes by how freindly are they to the gene that is represented by a row. Row is 'our' gene, column is the tester. The matrix is asymmetric.

Let's apply the functions to our example.

```{r}
ranks<-RankByBackwardsRank(correl)
ranks
```

#### Distance by backwards ranking

To apply most standard clustering techniques, we need a symmetric distance with self-distance = 0. We can map RBR ranks $F(j|i)$ and $F(i|j)$ on $[0..1]$ by dividing then by $k$ and then choose more marginal of then (upper if they a cloase to 1 or lower is they are close to 0).

Applying to our example:

```{r}
distance<-DistanceByBackwardsRank(correl)
distance
```

